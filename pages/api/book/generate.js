import { openai } from '../../../lib/openai'; import { supabase } from '../../../lib/supabase'; import { jsonResponse, requireSecret } from '../../../lib/utils';
import fs from 'fs'; import path from 'path'; import { v4 as uuidv4 } from 'uuid';
import { Document, Packer, Paragraph, HeadingLevel, TextRun, PageBreak } from 'docx';
const generator=fs.readFileSync(path.join(process.cwd(),'prompts/book_generator.md'),'utf8');
export default async function handler(req,res){ try{ if(req.method!=='POST') return jsonResponse(res,405,{error:'Method not allowed'}); requireSecret(req); const { intake_id } = req.body || {}; if(!intake_id) return jsonResponse(res,400,{error:'intake_id required'});
const { data:intake, error:e1 } = await supabase.from('intakes').select('*').eq('id',intake_id).single(); if(e1||!intake) return jsonResponse(res,404,{error:e1?.message||'intake not found'});
const outlineResp=await openai.chat.completions.create({ model:process.env.OPENAI_MODEL_BOOK||'gpt-5', temperature:1, messages:[{role:'system',content:generator},{role:'user',content:'BRIEF:\n'+JSON.stringify(intake.brief,null,2)+'\nGenera SOLO el campo "outline" en JSON válido.'}] });
const outlineText=outlineResp.choices?.[0]?.message?.content||'{}'; const r1=outlineText.match(/\{[\s\S]*\}$/); const outlineJson=JSON.parse(r1?r1[0]:'{"outline":[]}'); const outline=outlineJson.outline||[];
const chapters=[]; for(const it of outline){ const ch=await openai.chat.completions.create({ model:process.env.OPENAI_MODEL_BOOK||'gpt-5', temperature:1, messages:[{role:'system',content:generator},{role:'user',content:'BRIEF:\n'+JSON.stringify(intake.brief,null,2)+'\nEscribe el CAPITULO '+it.n+' titulado "'+it.titulo+'" (JSON con campo "capitulos":[{n,titulo,texto}]).'}] }); const t=ch.choices?.[0]?.message?.content||'{}'; const r=t.match(/\{[\s\S]*\}$/); const j=JSON.parse(r?r[0]:'{"capitulos":[]}'); if(j.capitulos&&j.capitulos.length) chapters.push(j.capitulos[0]); }
const docChildren=[]; if(intake.brief?.dedicatoria){ docChildren.push(new Paragraph({text:'Dedicatoria',heading:HeadingLevel.HEADING_1})); docChildren.push(new Paragraph(intake.brief.dedicatoria)); docChildren.push(new Paragraph({children:[new PageBreak()]})); }
docChildren.push(new Paragraph({text:intake.brief?.titulo_provisional||'Libro sin título',heading:HeadingLevel.TITLE})); docChildren.push(new Paragraph(' '));
if(intake.sinopsis){ docChildren.push(new Paragraph({text:'Sinopsis',heading:HeadingLevel.HEADING_1})); docChildren.push(new Paragraph(intake.sinopsis)); docChildren.push(new Paragraph({children:[new PageBreak()]})); }
chapters.forEach((c,i)=>{ docChildren.push(new Paragraph({text:c.titulo||('Capítulo '+(i+1)),heading:HeadingLevel.HEADING_1})); docChildren.push(new Paragraph(' ')); docChildren.push(new Paragraph(new TextRun(c.texto||''))); if(i<chapters.length-1) docChildren.push(new Paragraph({children:[new PageBreak()]})); });
const doc=new Document({sections:[{children:docChildren}]}); const buf=await Packer.toBuffer(doc); const fileName=`libro_${intake_id}_${uuidv4().slice(0,8)}.docx`;
const up=await supabase.storage.from('books').upload(fileName, buf, {contentType:'application/vnd.openxmlformats-officedocument.wordprocessingml.document', upsert:false}); if(up.error) return jsonResponse(res,500,{error:up.error.message});
const pub=supabase.storage.from('books').getPublicUrl(fileName); const url=pub.data?.publicUrl||''; await supabase.from('book_jobs').insert({intake_id:intake_id,status:'completed',output_url:url});
return jsonResponse(res,200,{ok:true,url,chapters:chapters.length}); }catch(e){ const code=e.code===403?403:500; return jsonResponse(res,code,{error:e.message||'error'});} }
